From d4bf9d28b79ae0ca5fadb51c65aabc1f483132f1 Mon Sep 17 00:00:00 2001
From: Rob Clark <robdclark@chromium.org>
Date: Fri, 12 Jul 2024 14:27:21 -0700
Subject: [PATCH 08/17] freedreno/a6xx: Implement S8 support

Basically z32+s8 mode but without the z32.

Signed-off-by: Rob Clark <robdclark@chromium.org>
Part-of: <https://gitlab.freedesktop.org/mesa/mesa/-/merge_requests/30064>
---
 .../drivers/freedreno/a6xx/fd6_gmem.cc        | 62 ++++++++++++-------
 1 file changed, 40 insertions(+), 22 deletions(-)

diff --git a/src/gallium/drivers/freedreno/a6xx/fd6_gmem.cc b/src/gallium/drivers/freedreno/a6xx/fd6_gmem.cc
index f4db66ea53b..12ae7714d61 100644
--- a/src/gallium/drivers/freedreno/a6xx/fd6_gmem.cc
+++ b/src/gallium/drivers/freedreno/a6xx/fd6_gmem.cc
@@ -166,7 +166,7 @@ emit_zs(struct fd_ringbuffer *ring, struct pipe_surface *zsbuf,
 {
    if (zsbuf) {
       struct fd_resource *rsc = fd_resource(zsbuf->texture);
-      enum a6xx_depth_format fmt = fd6_pipe2depth(zsbuf->format);
+      struct fd_resource *stencil = rsc->stencil;
       uint32_t stride = fd_resource_pitch(rsc, zsbuf->u.tex.level);
       uint32_t array_stride = fd_resource_layer_stride(rsc, zsbuf->u.tex.level);
       uint32_t base = gmem ? gmem->zsbuf_base[0] : 0;
@@ -179,38 +179,56 @@ emit_zs(struct fd_ringbuffer *ring, struct pipe_surface *zsbuf,
        */
       fd_ringbuffer_attach_bo(ring, rsc->bo);
 
-      OUT_REG(
-         ring, RB_DEPTH_BUFFER_INFO(CHIP, .depth_format = fmt),
-         A6XX_RB_DEPTH_BUFFER_PITCH(stride),
-         A6XX_RB_DEPTH_BUFFER_ARRAY_PITCH(array_stride),
-         A6XX_RB_DEPTH_BUFFER_BASE(.bo = rsc->bo, .bo_offset = offset),
-         A6XX_RB_DEPTH_BUFFER_BASE_GMEM(base));
+      if (zsbuf->format == PIPE_FORMAT_S8_UINT) {
+         /* S8 is implemented as Z32_S8 minus the Z32 plane: */
+         enum a6xx_depth_format fmt = DEPTH6_32;
 
-      OUT_REG(ring, A6XX_GRAS_SU_DEPTH_BUFFER_INFO(.depth_format = fmt));
+         OUT_REG(
+            ring, RB_DEPTH_BUFFER_INFO(CHIP, .depth_format = fmt),
+            A6XX_RB_DEPTH_BUFFER_PITCH(0),
+            A6XX_RB_DEPTH_BUFFER_ARRAY_PITCH(0),
+            A6XX_RB_DEPTH_BUFFER_BASE(.qword = 0),
+            A6XX_RB_DEPTH_BUFFER_BASE_GMEM(base));
 
-      OUT_PKT4(ring, REG_A6XX_RB_DEPTH_FLAG_BUFFER_BASE, 3);
-      fd6_emit_flag_reference(ring, rsc, zsbuf->u.tex.level,
-                              zsbuf->u.tex.first_layer);
+         OUT_REG(ring, A6XX_GRAS_SU_DEPTH_BUFFER_INFO(.depth_format = fmt));
 
-      /* NOTE: blob emits GRAS_LRZ_CNTL plus GRAZ_LRZ_BUFFER_BASE
-       * plus this CP_EVENT_WRITE at the end in it's own IB..
-       */
-      OUT_PKT7(ring, CP_EVENT_WRITE, 1);
-      OUT_RING(ring, CP_EVENT_WRITE_0_EVENT(LRZ_CLEAR));
+         stencil = rsc;
+      } else {
+         enum a6xx_depth_format fmt = fd6_pipe2depth(zsbuf->format);
+
+         OUT_REG(
+            ring, RB_DEPTH_BUFFER_INFO(CHIP, .depth_format = fmt),
+            A6XX_RB_DEPTH_BUFFER_PITCH(stride),
+            A6XX_RB_DEPTH_BUFFER_ARRAY_PITCH(array_stride),
+            A6XX_RB_DEPTH_BUFFER_BASE(.bo = rsc->bo, .bo_offset = offset),
+            A6XX_RB_DEPTH_BUFFER_BASE_GMEM(base));
+
+         OUT_REG(ring, A6XX_GRAS_SU_DEPTH_BUFFER_INFO(.depth_format = fmt));
+
+         OUT_PKT4(ring, REG_A6XX_RB_DEPTH_FLAG_BUFFER_BASE, 3);
+         fd6_emit_flag_reference(ring, rsc, zsbuf->u.tex.level,
+                                 zsbuf->u.tex.first_layer);
+
+         /* NOTE: blob emits GRAS_LRZ_CNTL plus GRAZ_LRZ_BUFFER_BASE
+          * plus this CP_EVENT_WRITE at the end in it's own IB..
+          */
+         OUT_PKT7(ring, CP_EVENT_WRITE, 1);
+         OUT_RING(ring, CP_EVENT_WRITE_0_EVENT(LRZ_CLEAR));
+      }
 
-      if (rsc->stencil) {
-         stride = fd_resource_pitch(rsc->stencil, zsbuf->u.tex.level);
-         array_stride = fd_resource_layer_stride(rsc->stencil, zsbuf->u.tex.level);
+      if (stencil) {
+         stride = fd_resource_pitch(stencil, zsbuf->u.tex.level);
+         array_stride = fd_resource_layer_stride(stencil, zsbuf->u.tex.level);
          uint32_t base = gmem ? gmem->zsbuf_base[1] : 0;
          uint32_t offset =
-            fd_resource_offset(rsc->stencil, zsbuf->u.tex.level, zsbuf->u.tex.first_layer);
+            fd_resource_offset(stencil, zsbuf->u.tex.level, zsbuf->u.tex.first_layer);
 
-         fd_ringbuffer_attach_bo(ring, rsc->stencil->bo);
+         fd_ringbuffer_attach_bo(ring, stencil->bo);
 
          OUT_REG(ring, RB_STENCIL_INFO(CHIP, .separate_stencil = true),
                  A6XX_RB_STENCIL_BUFFER_PITCH(stride),
                  A6XX_RB_STENCIL_BUFFER_ARRAY_PITCH(array_stride),
-                 A6XX_RB_STENCIL_BUFFER_BASE(.bo = rsc->stencil->bo, .bo_offset = offset),
+                 A6XX_RB_STENCIL_BUFFER_BASE(.bo = stencil->bo, .bo_offset = offset),
                  A6XX_RB_STENCIL_BUFFER_BASE_GMEM(base));
       } else {
          OUT_REG(ring, RB_STENCIL_INFO(CHIP, 0));
-- 
2.45.2

